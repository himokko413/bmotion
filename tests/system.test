# vim: ft=tcl
source "tests/eggdrop-shim.tcl"

set botnick "NoTopic"
set bMotionRoot "."

source "bMotion.tcl"

package require tcltest
namespace import ::tcltest::*

eval ::tcltest::configure $argv

::tcltest::customMatch noglob shim_no_match_glob

# disable things like typos
set bMotion_test_harness 1

test binds-1 "check the join event is bound" -body {
    return [shim_check_for_bind join bMotion_event_onjoin]
} -result {1}

test binds-2 "check the mode event is bound" -body {
    return [shim_check_for_bind mode bMotion_event_mode]
} -result {1}

test binds-3 "check the pubm event is bound" -body {
    return [shim_check_for_bind pubm bMotion_event_main]
} -result {1}

test binds-4 "check the quit event is bound" -body {
    return [shim_check_for_bind sign bMotion_event_onquit]
} -result {1}

test binds-5 "check the nick event is bound" -body {
    return [shim_check_for_bind nick bMotion_event_nick]
} -result {1}

test binds-6 "check the part event is bound" -body {
    return [shim_check_for_bind part bMotion_event_onpart]
} -result {1}

test binds-7 "check the ctcp event is bound" -body {
    return [shim_check_for_bind ctcp bMotion_event_action]
} -result {1}

test binds-8 "check the msg event is bound" -body {
    return [shim_check_for_bind msg msg_bmotioncommand]
} -result {1}

test binds-9 "check the out pub admin event is not bound" -body {
    return [shim_check_for_bind pub bMotionAdminHandler]
} -result {0}

test binds-10 "check the pub admin event is bound" -body {
    return [shim_check_for_bind pub bMotionAdminHandler2]
} -result {1}

test binds-11 "check the dcc admin event is bound" -body {
    return [shim_check_for_bind dcc bMotion_dcc_command]
} -result {1}

test binds-12 "check the bedtime event is bound" -body {
    return [shim_check_for_bind time bMotion_check_tired2]
} -result {1}

test system-log-1 "system log category exists" -body {
    return [bMotion_log_category_exists "system"]
} -result {1}

test system-update-chanlist-1 "update chanlist works" -setup {
    bMotion_update_chanlist
} -body {
    return $::bMotionChannels
} -result [list #bmotion]

test system-init-chanvars-1 "last event value is set for #bmotion" -body {
    return [info exists ::bMotionLastEvent(#bmotion)]
} -result {1}

test system-init-chanvars-2 "admin silence value is cleared for #bmotion" -body {
    return $::bMotionInfo(adminSilence,#bmotion)
} -result {0}

test system-init-chanvars-3 "last value is cleared for #bmotion" -body {
    return $::bMotionCache(#bmotion,last)
} -result {0}

test system-last-event-1 "last event set works" -setup {
    set testval [bMotion_set_last_event #bmotion]
} -body {
    return [expr $::bMotionLastEvent(#bmotion) == $testval]
} -result {1}

test system-last-event-2 "last event get works" -setup {
    set ::bMotionLastEvent(#bmotion) 5
} -body {
    return [bMotion_get_last_event #bmotion]
} -result {5}

test system-active-enough-1 "active enough handles missing data" -setup {
    unset ::bMotionLastEvent(#bmotion)
} -body {
    return [bMotion_is_active_enough #bmotion]
} -result {1}

test system-active-enough-2 "active enough returns 1 for time within limit" -setup {
    set ::bMotionInfo(maxIdleGap) 1
    set ::bMotionLastEvent(#bmotion) [expr [clock seconds] - 10]
} -body {
    return [bMotion_is_active_enough #bmotion]
} -result {1}

test system-active-enough-3 "active enough returns 0 for time outside limit" -setup {
    set ::bMotionInfo(maxIdleGap) 1
    set ::bMotionLastEvent(#bmotion) [expr [clock seconds] - 70]
} -body {
    return [bMotion_is_active_enough #bmotion]
} -result {0}

test system-random-away-1 "random away doesn't work in bitlbee mode" -setup {
    set ::bMotionSettings(bitlbee) 1
    set ::bMotionInfo(away) 0
} -body {
    return [bMotion_random_away]
} -cleanup {
    set ::bMotionSettings(bitlbee) 0
} -result {0}

test system-random-away-2 "random away doesn't work if useAway is 0" -setup {
    set ::bMotionSettings(useAway) 0
    set ::bMotionInfo(away) 0
} -body {
    return [bMotion_random_away]
} -cleanup {
    set ::bMotionSettings(useAway) 1
} -result {0}

test system-random-away-3 "random away doesn't fire if channels are too idle" -setup {
    set ::bMotionLastEvent(#bmotion) [expr [clock seconds] - 62]
    set ::bMotionInfo(maxIdleGap) 1
    set ::bMotionInfo(away) 0
} -body {
    return [bMotion_random_away]
} -result {0}

test system-random-away-4 "random away does fire if channels are not idle" -setup {
    set ::bMotionLastEvent(#bmotion) [expr [clock seconds] - 58]
    set ::bMotionInfo(maxIdleGap) 1
    set ::bMotionSettings(awaychance) 50
    set ::bMotionInfo(away) 0
    shim_load_rng [list 40 0]
} -body {
    return [bMotion_random_away]
} -result {1}

test system-random-away-5 "random away does not fire if chance is too high" -setup {
    set ::bMotionLastEvent(#bmotion) [expr [clock seconds] - 58]
    set ::bMotionInfo(maxIdleGap) 1
    set ::bMotionSettings(awaychance) 50
    set ::bMotionInfo(away) 0
    shim_load_rng [list 60 0]
} -body {
    return [bMotion_random_away]
} -result {0}

test system-random-away-5 "random away does not fire if already away" -setup {
    set ::bMotionLastEvent(#bmotion) [expr [clock seconds] - 58]
    set ::bMotionInfo(maxIdleGap) 1
    set ::bMotionSettings(awaychance) 50
    set ::bMotionInfo(away) 1
    shim_load_rng [list 40 0]
} -body {
    return [bMotion_random_away]
} -result {0}

#TODO: test doRandomStuff

test system-set-away-1 "set random away sets us away" -setup {
    set ::bMotionInfo(away) 0
    set ::bMotionInfo(silence) 0
} -body {
    bMotionSetRandomAway
    return [expr ($::bMotionInfo(away) == 1) && ($::bMotionInfo(silence) == 1)]
} -result {1} -output {*] AWAY :*} -match glob


test system-set-away-2 "set random away sends output to channels" -setup {
    set ::bMotionInfo(away) 0
    set ::bMotionInfo(silence) 0
    bMotion_queue_flush
} -body {
    bMotionSetRandomAway
    shim_run_all_queue
} -output {*] PRIVMSG #bmotion :*ACTION is away:*} -match glob

#TODO: test negative case


test system-set-back-1 "set back sets us back on the server" -setup {
    set ::bMotionInfo(away) 0
    set ::bMotionInfo(silence) 0
} -body {
    bMotionSetRandomBack
    return [expr ($::bMotionInfo(away) == 0) && ($::bMotionInfo(silence) == 0)]
} -result {1} -output {*] AWAY*} -match glob


test system-set-back-2 "set back sends output to channels" -setup {
    set ::bMotionInfo(away) 0
    set ::bMotionInfo(silence) 0
} -body {
    bMotionSetRandomBack
    shim_run_all_queue
    return [expr ($::bMotionInfo(away) == 0) && ($::bMotionInfo(silence) == 0)]
} -result {1} -output {*] PRIVMSG #bmotion :*ACTION is back*} -match glob

# set ::bMotion_log_level 5
# set ::bMotion_log_categories [list "system"]

test system-talking-to-me-1 "nick at start of line means talking to the bot" -body {
    return [bMotionTalkingToMe "NoTopic: hello there"]
} -result {1}

test system-talking-to-me-2 "nick at start of line means talking to the bot" -body {
    return [bMotionTalkingToMe "NoTopic, hello there"]
} -result {1}

test system-talking-to-me-3 "nick at start of line means talking to the bot" -body {
    return [bMotionTalkingToMe "NoTopic hello there"]
} -result {1}

test system-talking-to-me-4 "nick at end of line means talking to the bot" -body {
    return [bMotionTalkingToMe "hello there NoTopic"]
} -result {1}

test system-talking-to-me-5 "nick at end of line means talking to the bot" -body {
    return [bMotionTalkingToMe "hello there NoTopic!"]
} -result {1}

test system-talking-to-me-6 "nick at end of line means talking to the bot" -body {
    return [bMotionTalkingToMe "hello there NoTopic?"]
} -result {1}

test system-talking-to-me-7 "nick at end of line means talking to the bot" -body {
    return [bMotionTalkingToMe "hello there NoTopic~"]
} -result {1}

test system-talking-to-me-8 "wrong nick at start of line doesn't mean talking to me" -body {
    return [bMotionTalkingToMe "MonicaOff: hello there"]
} -result {0}

test system-talking-to-me-9 "no nick in line doesn't mean talking to me" -body {
    return [bMotionTalkingToMe "hello there"]
} -result {0}

test system-silence-1 "setting silence sets the bot away" -setup {
    set ::bMotionInfo(silence) 0
    set ::bMotionInfo(away) 0
} -body {
    bMotionSilence jms jms!jms@thing #bmotion
    return [expr ($::bMotionInfo(away) == 1) && ($::bMotionInfo(silence) == 1)]
} -result {1}

test system-silence-2 "setting silence sets the bot away on irc" -setup {
    set ::bMotionInfo(silence) 0
    set ::bMotionInfo(away) 0
} -body {
    bMotionSilence jms jms!jms@thing #bmotion
} -output {*] AWAY :afk (jms #bmotion)*} -match glob -result {1}

test system-silence-3 "setting silence responds to the channel" -setup {
    set ::bMotionInfo(silence) 0
    set ::bMotionInfo(away) 0
    bMotion_abstract_register "silenceAways"
    bMotion_abstract_reset "silenceAways"
    bMotion_abstract_add "silenceAways" "test"
    bMotion_queue_flush
} -body {
    bMotionSilence jms jms!jms@thing #bmotion
    shim_run_all_queue
} -output {*] PRIVMSG #bmotion :test*} -match glob

test system-silence-4 "setting silence sets a timer to come back" -setup {
    set ::bMotionInfo(silence) 0
    set ::bMotionInfo(away) 0
} -body {
    bMotionSilence jms jms!jms@thing #bmotion
    shim_check_for_timer timer bMotionUnSilence
} -result {1}

test system-silence-5 "setting silence ignores if it's already done" -setup {
    set ::bMotionInfo(silence) 1
    set ::bMotionInfo(away) 1
} -body {
    return [bMotionSilence jms jms!jms@thing #bmotion]
} -output {*] NOTICE jms :I already am*} -match glob -result {0}

test system-unsilence-1 "unsilence sets us back on IRC" -body {
    bMotionUnSilence
} -output {*] AWAY*} -match glob -result {0}

test system-unsilence-2 "unsilence clears silence and away vars" -setup {
    set ::bMotionInfo(silence) 1
    set ::bMotionInfo(away) 1
} -body {
    bMotionUnSilence
    return [expr ($::bMotionInfo(away) == 0) && ($::bMotionInfo(silence) == 0)]
} -result {1}

test system-getgender-1 "male user gender returned correctly" -body {
    return [bMotionGetGender "male" "host"]
} -result {male}

test system-getgender-2 "female user gender returned correctly" -body {
    return [bMotionGetGender "female" "host"]
} -result {female}

test system-getgender-3 "unknown user gender returned correctly" -body {
    return [bMotionGetGender "unknown" "host"]
} -result {unknown}

test system-putadmin-1 "putadmin to dcc works" -setup {
    bMotion_plugins_settings_set "admin" "idx" "" "" "1"
    bMotion_plugins_settings_set "admin" "type" "" "" "dcc"
} -body {
    bMotion_putadmin "test to dcc"
} -output {*DCC*] (1) test to dcc*} -match glob -result {0}

test system-putadmin-2 "putadmin to irc works" -setup {
    bMotion_plugins_settings_set "admin" "target" "" "" "#output"
    bMotion_plugins_settings_set "admin" "type" "" "" "irc"
} -body {
    bMotion_putadmin "test to irc"
} -output {*HELP*] PRIVMSG #output :test to irc*} -match glob -result {0}

test system-putadmin-3 "putadmin changes tabs to spaces" -setup {
    bMotion_plugins_settings_set "admin" "target" "" "" "#output"
    bMotion_plugins_settings_set "admin" "type" "" "" "irc"
} -body {
    bMotion_putadmin "\ttest to irc"
} -output {*HELP*] PRIVMSG #output :  test to irc*} -match glob -result {0}

#TODO test bMotion_dcc_command

test system-dcc-help-1 "bMotion_dcc_help returns redirect message" -body {
    bMotion_dcc_help test 1 arg
} -output {*] (1) Please use .bmotion help*} -match glob -result {0}

cleanupTests
